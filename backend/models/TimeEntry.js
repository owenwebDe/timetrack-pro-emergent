// backend/models/TimeEntry.js - Updated with organization support
const mongoose = require("mongoose");

const timeEntrySchema = new mongoose.Schema({
  id: {
    type: String,
    required: true,
    unique: true,
  },
  organizationId: {
    type: String,
    required: true,
    // References Organization.id - all time entries must belong to an organization
  },
  user_id: {
    type: String,
    required: true,
    // Must be a user within the same organization
  },
  project_id: {
    type: String,
    required: true,
    // Must be a project within the same organization
  },
  task_id: {
    type: String,
    required: true,
    // Must be a task within the same organization
  },
  description: {
    type: String,
    trim: true,
    maxlength: 500,
  },
  start_time: {
    type: Date,
    required: true,
  },
  end_time: {
    type: Date,
    default: null,
    validate: {
      validator: function (endTime) {
        return !endTime || endTime > this.start_time;
      },
      message: "End time must be after start time",
    },
  },
  duration: {
    type: Number, // in seconds
    default: 0,
    min: 0,
  },
  is_manual: {
    type: Boolean,
    default: false,
  },
  is_active: {
    type: Boolean,
    default: false, // True if timer is currently running
  },
  activity_level: {
    type: Number,
    min: 0,
    max: 100,
    default: 0,
  },
  screenshots: [
    {
      timestamp: { type: Date, required: true },
      image: String, // Base64 encoded image or URL
      activity: { type: Number, min: 0, max: 100 },
      mouseClicks: { type: Number, default: 0 },
      keystrokes: { type: Number, default: 0 },
    },
  ],
  keyboard_activity: {
    type: Number,
    min: 0,
    default: 0,
  },
  mouse_activity: {
    type: Number,
    min: 0,
    default: 0,
  },
  applications: [
    {
      name: { type: String, required: true },
      timeSpent: { type: Number, default: 0 }, // in seconds
      category: String,
      windowTitle: String,
      firstUsed: Date,
      lastUsed: Date,
    },
  ],
  websites: [
    {
      url: { type: String, required: true },
      domain: String,
      title: String,
      timeSpent: { type: Number, default: 0 }, // in seconds
      category: String,
      firstVisited: Date,
      lastVisited: Date,
    },
  ],
  tags: [
    {
      type: String,
      trim: true,
      maxlength: 30,
    },
  ],
  billable: {
    type: Boolean,
    default: true,
  },
  approved: {
    type: Boolean,
    default: false,
  },
  approvedBy: {
    type: String, // User ID who approved this entry
    default: null,
  },
  approvedAt: {
    type: Date,
    default: null,
  },
  hourlyRate: {
    type: Number,
    min: 0,
    default: 0,
  },
  totalAmount: {
    type: Number,
    min: 0,
    default: 0,
  },
  currency: {
    type: String,
    default: "USD",
    enum: ["USD", "EUR", "GBP", "CAD", "AUD"],
  },
  location: {
    ip: String,
    country: String,
    city: String,
    timezone: String,
  },
  device: {
    type: String,
    enum: ["desktop", "mobile", "tablet"],
    default: "desktop",
  },
  notes: {
    type: String,
    trim: true,
    maxlength: 1000,
  },
  flags: {
    // Flags for review or issues
    needsReview: { type: Boolean, default: false },
    hasIssue: { type: Boolean, default: false },
    isEdited: { type: Boolean, default: false },
    autoGenerated: { type: Boolean, default: false },
  },
  editHistory: [
    {
      editedBy: String,
      editedAt: { type: Date, default: Date.now },
      changes: Map,
      reason: String,
    },
  ],
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});

// Compound indexes for organization-scoped queries
timeEntrySchema.index({ organizationId: 1, user_id: 1, start_time: -1 });
timeEntrySchema.index({ organizationId: 1, project_id: 1, start_time: -1 });
timeEntrySchema.index({ organizationId: 1, task_id: 1 });
timeEntrySchema.index({ organizationId: 1, is_active: 1 });
timeEntrySchema.index({ organizationId: 1, billable: 1, approved: 1 });
timeEntrySchema.index({ organizationId: 1, start_time: 1, end_time: 1 });

// Update the updatedAt field before saving
timeEntrySchema.pre("save", function (next) {
  this.updatedAt = Date.now();
  next();
});

// Calculate duration when end_time is set
timeEntrySchema.pre("save", function (next) {
  if (this.end_time && this.start_time) {
    this.duration = Math.floor((this.end_time - this.start_time) / 1000);
  }
  next();
});

// Calculate total amount based on duration and hourly rate
timeEntrySchema.pre("save", function (next) {
  if (this.duration && this.hourlyRate && this.billable) {
    const hours = this.duration / 3600;
    this.totalAmount = hours * this.hourlyRate;
  } else {
    this.totalAmount = 0;
  }
  next();
});

// Auto-approve entries under certain conditions
timeEntrySchema.pre("save", function (next) {
  // Auto-approve if it's a short manual entry (less than 8 hours)
  if (this.is_manual && this.duration < 28800 && !this.approved) {
    // 8 hours in seconds
    this.approved = true;
    this.approvedAt = new Date();
    this.approvedBy = this.user_id; // Self-approved
  }
  next();
});

// Virtual for organization
timeEntrySchema.virtual("organization", {
  ref: "Organization",
  localField: "organizationId",
  foreignField: "id",
  justOne: true,
});

// Virtual for user
timeEntrySchema.virtual("user", {
  ref: "User",
  localField: "user_id",
  foreignField: "id",
  justOne: true,
});

// Virtual for project
timeEntrySchema.virtual("project", {
  ref: "Project",
  localField: "project_id",
  foreignField: "id",
  justOne: true,
});

// Virtual for task
timeEntrySchema.virtual("task", {
  ref: "Task",
  localField: "task_id",
  foreignField: "id",
  justOne: true,
});

// Virtual for formatted duration
timeEntrySchema.virtual("formattedDuration").get(function () {
  if (!this.duration) return "0h 0m";
  const hours = Math.floor(this.duration / 3600);
  const minutes = Math.floor((this.duration % 3600) / 60);
  return `${hours}h ${minutes}m`;
});

// Virtual for productivity score
timeEntrySchema.virtual("productivityScore").get(function () {
  if (this.activity_level === 0) return 0;

  // Consider activity level, application usage, and screenshot analysis
  let score = this.activity_level;

  // Bonus for consistent activity (having screenshots)
  if (this.screenshots.length > 0) {
    score += 10;
  }

  // Penalty for too many non-work applications
  const totalAppTime = this.applications.reduce(
    (sum, app) => sum + app.timeSpent,
    0
  );
  const workApps = this.applications.filter(
    (app) => !["entertainment", "social", "games"].includes(app.category)
  );
  const workAppTime = workApps.reduce((sum, app) => sum + app.timeSpent, 0);

  if (totalAppTime > 0) {
    const workRatio = workAppTime / totalAppTime;
    score = score * workRatio;
  }

  return Math.min(Math.round(score), 100);
});

// Virtual for break detection
timeEntrySchema.virtual("hasLongBreaks").get(function () {
  if (this.screenshots.length < 2) return false;

  // Check for gaps of more than 15 minutes between screenshots
  for (let i = 1; i < this.screenshots.length; i++) {
    const timeDiff =
      this.screenshots[i].timestamp - this.screenshots[i - 1].timestamp;
    if (timeDiff > 15 * 60 * 1000) {
      // 15 minutes in milliseconds
      return true;
    }
  }
  return false;
});

// Instance method to check if user can view this entry
timeEntrySchema.methods.canView = function (user) {
  // Same organization check
  if (this.organizationId !== user.organizationId) {
    return false;
  }

  // Owner, admin, or manager can view
  return (
    this.user_id === user.id || user.role === "admin" || user.role === "manager"
  );
};

// Instance method to check if user can edit this entry
timeEntrySchema.methods.canEdit = function (user) {
  // Same organization check
  if (this.organizationId !== user.organizationId) {
    return false;
  }

  // Only owner or admin can edit, and only if not approved by someone else
  const canEditBasics = this.user_id === user.id || user.role === "admin";
  const notApprovedByOthers =
    !this.approved || this.approvedBy === this.user_id;

  return canEditBasics && notApprovedByOthers;
};

// Instance method to approve entry
timeEntrySchema.methods.approve = function (approverId) {
  this.approved = true;
  this.approvedBy = approverId;
  this.approvedAt = new Date();
  return this;
};

// Instance method to add screenshot
timeEntrySchema.methods.addScreenshot = function (screenshotData) {
  this.screenshots.push({
    timestamp: screenshotData.timestamp || new Date(),
    image: screenshotData.image,
    activity: screenshotData.activity || 0,
    mouseClicks: screenshotData.mouseClicks || 0,
    keystrokes: screenshotData.keystrokes || 0,
  });

  // Keep only last 50 screenshots to avoid document size issues
  if (this.screenshots.length > 50) {
    this.screenshots = this.screenshots.slice(-50);
  }

  return this;
};

// Instance method to track edit
timeEntrySchema.methods.trackEdit = function (editedBy, changes, reason = "") {
  this.flags.isEdited = true;
  this.editHistory.push({
    editedBy,
    editedAt: new Date(),
    changes: new Map(Object.entries(changes)),
    reason,
  });

  // Keep only last 10 edits
  if (this.editHistory.length > 10) {
    this.editHistory = this.editHistory.slice(-10);
  }

  return this;
};

// Static method to find entries in organization
timeEntrySchema.statics.findInOrganization = function (
  organizationId,
  conditions = {}
) {
  return this.find({ organizationId, ...conditions });
};

// Static method to find active entries in organization
timeEntrySchema.statics.findActiveEntries = function (organizationId) {
  return this.find({ organizationId, is_active: true });
};

// Static method to find user's entries in date range
timeEntrySchema.statics.findUserEntriesInRange = function (
  organizationId,
  userId,
  startDate,
  endDate
) {
  return this.find({
    organizationId,
    user_id: userId,
    start_time: { $gte: startDate, $lte: endDate },
  }).sort({ start_time: -1 });
};

// Static method to get time stats for organization
timeEntrySchema.statics.getOrgTimeStats = function (
  organizationId,
  startDate,
  endDate
) {
  const matchStage = { organizationId };
  if (startDate && endDate) {
    matchStage.start_time = { $gte: startDate, $lte: endDate };
  }

  return this.aggregate([
    { $match: matchStage },
    {
      $group: {
        _id: null,
        totalTime: { $sum: "$duration" },
        billableTime: {
          $sum: {
            $cond: [{ $eq: ["$billable", true] }, "$duration", 0],
          },
        },
        totalEarnings: { $sum: "$totalAmount" },
        avgActivity: { $avg: "$activity_level" },
        entryCount: { $sum: 1 },
        approvedEntries: {
          $sum: {
            $cond: [{ $eq: ["$approved", true] }, 1, 0],
          },
        },
      },
    },
  ]);
};

// Static method to find entries needing approval
timeEntrySchema.statics.findEntriesNeedingApproval = function (organizationId) {
  return this.find({
    organizationId,
    approved: false,
    "flags.needsReview": true,
  }).sort({ start_time: -1 });
};

// Remove sensitive information from JSON output
timeEntrySchema.methods.toJSON = function () {
  const entry = this.toObject();

  // Remove sensitive location data for non-admins
  if (entry.location) {
    delete entry.location.ip;
  }

  return entry;
};

// Safe info for managers/reports
timeEntrySchema.methods.toReportJSON = function () {
  return {
    id: this.id,
    user_id: this.user_id,
    project_id: this.project_id,
    task_id: this.task_id,
    description: this.description,
    start_time: this.start_time,
    end_time: this.end_time,
    duration: this.duration,
    formattedDuration: this.formattedDuration,
    activity_level: this.activity_level,
    billable: this.billable,
    approved: this.approved,
    hourlyRate: this.hourlyRate,
    totalAmount: this.totalAmount,
    productivityScore: this.productivityScore,
    createdAt: this.createdAt,
  };
};

module.exports = mongoose.model("TimeEntry", timeEntrySchema);
